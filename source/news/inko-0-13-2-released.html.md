---
author: Yorick Peterse
title: "Inko 0.13.2 released"
date: "2023-12-14 14:00:00 UTC"
---

We're pleased to announce the release of Inko 0.13.2. This release is a smaller
release that focuses on fixing various bugs, extending the standard library, and
improving performance.

## Table of contents
{:.no_toc}

* TOC
{:toc}

For the full list of changes, refer to the
[changelog](https://github.com/inko-lang/inko/blob/main/CHANGELOG.md#0132-2023-12-14).

A special thanks to the following people for contributing changes included in
this release:

- [awoo](https://github.com/awoo-civ)
- [Bartek Iwańczuk](https://github.com/bartlomieju)
- [Dusty Phillips](https://github.com/dusty-phillips)
- [jinyus](https://github.com/jinyus)
- [Tomoki Aonuma](https://github.com/uasi)

We'd also like to thank the following people for financially supporting the
development of Inko:

- [Amidamaru](https://github.com/thaodt)
- [Dusty Phillips](https://dusty.phillips.codes)
- [Evan Ovadia](https://github.com/Verdagon)
- [Kiril Mihaylov](https://github.com/KirilMihaylov)
- [SEKUN](https://sekun.dev)

## Scheduling using time slices instead of reductions

Before 0.13.2, Inko's scheduler used "reductions" to prevent processes from
running on an OS thread indefinitely. The implementation was simple: each
process starts with a "reduction" counter set to N, reduces it for certain
operations (e.g. method calls), and yields back to the scheduler when the
counter reaches zero. The next time the process is scheduled the counter is
reset, and the work repeats itself.

While this implementation is simple, it's also costly: the reductions were
applied by calling a function provided by the runtime library and as such can't
be inlined. This is done for every method call, resulting in a significant
overhead. Even if the function were to be inlined, the constant mutation of a
counter would likely result in caches being evicted non-stop, resulting in poor
performance.

Inko 0.13.2 introduces a new mechanism that reduces the scheduler overhead by up
to 40% for applications that call many methods. The way this new setup works is
as follows:

A global counter is atomically incremented by a separate thread every 10
milliseconds. When a process is about to run, it obtains the current value of
this counter and stores it in itself. The compiler in turn inserts code at
various places, known as a "preemption point". This code checks the
process-local counter against the global counter, yielding control back to the
scheduler if the two values differ. Using pseudo code, this looks as follows:

```
if process.epoch != atomic-load(global_epoch) {
  yield
}
```

Atomic operations are performed using the "relaxed" ordering, meaning the
overhead is minimal.

Preemption points are _not_ inserted after every method call, instead they are
inserted at the end of loop iterations and before `next` and `break`
expressions. In addition, the code is generated by the compiler instead of
relying on function calls.

Processes of course still yield when performing asynchronous IO operations (when
needed), and threads blocked on blocking (file) IO are still replaced with
backup threads. This combination means the new setup is good enough to prevent
Inko processes from claiming an OS thread for too long, at a fraction of the
cost compared to the previous approach.

## Applying LLVM optimizations

Inko by default doesn't apply LLVM optimizations as we're still trying to figure
out which optimization passes are worth enabling. In addition, we're still
toying with the idea of replacing LLVM with [Cranelift](https://cranelift.dev/)
at some point in the future.

Unfortunately, this means performance can leave a lot to be desired. To work
around this for the time being, `inko build --opt=aggressive` now applies the
optimizations similar to those provided by `-O3` when using clang. Depending on
the application, this can improve performance at the cost of greatly increasing
compilation times.

## Improvements to maintaining unit tests

Maintaining unit tests is made easier as Inko now automatically generates the
test runner (`./test/main.inko`) when running `inko test`. This means you no
longer need to maintain this file and import new test files manually.

Refer to commit [da6ea1c](https://github.com/inko-lang/inko/commit/da6ea1c31150b92aa0094de0c8417875e24ac32f)
for more details. Thanks to [Bartek Iwańczuk](https://github.com/bartlomieju)
for implementing this!

## Recovering values when assigning process fields

Processes are defined using the `class async` syntax:

```inko
class async Foo[T] {
  let @value: T
}
```

When creating an instance of such a process, the values assigned to the fields
must be safe to be moved between process (known as "sendable" values). For
example, the following isn't valid:

```inko
let nums = [10]

Foo { @value = nums }
```

The reason this isn't valid is because the compiler doesn't know if there are
any references to `nums` when it's assigned to the `value` field. To make this
correct, we'd have to use the `recover` keyword, ensuring no outside references
to it exist (see [the documentation](https://docs.inko-lang.org/manual/v0.13.2/getting-started/memory-management/#unique-values-and-recovery)
for more details) and turning the type `Array[Int]` into `uni Array[Int]`:

```inko
let nums = recover [10]

Foo { @value = nums } # => Foo[uni Array[Int]]
```

This can create a problem: if the field type is generic, assigning it a `uni T`
value results in the generic type being inferred as an `uni` type, even if you
want it to be inferred as an owned value. To solve this, Inko 0.13.2 allows you
to use `recover` to turn an `uni T` into a `T` as part of the assignment like
so:

```inko
let nums = recover [10]

Foo { @value = recover nums } # => Foo[Array[Int]]
```

This is only allowed if the value of the assignment is the `recover` expression,
otherwise the compiler isn't able to guarantee no outside references to the
value exist at the time of assignment.

For more details, refer to commit
[1b61961](https://github.com/inko-lang/inko/commit/1b619615be160b29d97c123a4fa2e5e1d977e880)
and [issue #641](https://github.com/inko-lang/inko/issues/641).

## Constraining generics to owned types

This release introduces the `move` annotation for generic type parameters. Using
this keyword you can specify that a generic type parameter only accepts or
returns owned values. To illustrate this, consider this method:

```inko
fn foo[T](value: T) -> T {
  value
}
```

This method is generic and accepts values of any type and ownership:

```inko
foo([10, 20])     # => Array[Int]
foo(ref [10, 20]) # => ref Array[Int]
foo(mut [10, 20]) # => ref Array[Int]
```

Being generic over ownership does come with a restriction: if we don't know the
ownership of the value, we can't move out of the value using an `fn move`
method. Consider the following example:

```inko
trait Example {
  fn move example
}

fn foo[T: Example](value: T) {
  value.example
}
```

If we were to pass `foo` a reference (e.g. a `ref T`), we'd be able to move out
of the `T` and deallocate it prematurely.

To solve this, Inko now requires the `move` annotation for generic type
parameters to allow the use of moving methods. This means we have to change our
`foo` method to the following:

```inko
fn foo[T: Example](value: move T) {
  value.example
}
```

This is sound because by using `move T` we restrict the values to _owned_
values, which we can move out of.

When used in a return type, `move T` transforms the type assigned to `T` into
an owned value:

```inko
fn foo[T](value: T) -> move T {
  ...
}
```

This method would take a value of any ownership, and somehow convert it into an
owned value.

For more information, refer to commit
[c9c01ac](https://github.com/inko-lang/inko/commit/c9c01acb92080570bbce12cfa3bf7eda3f3425c6)

## Standard library improvements

The following methods have been added to the standard library:

- [`Iter.skip`](https://github.com/inko-lang/inko/commit/7a967b03d41186a891253d6296e42928c16537a3)
- [`Iter.skip_while` and `Iter.take_while`](https://github.com/inko-lang/inko/commit/c42baf42420b3851638b2e2062ad50e941922a79)
- [`Iter.take`](https://github.com/inko-lang/inko/commit/6c7da745c34a5ca62f1ef93e2617002b6e81b18c)
- [`Iter.try_each` and `Iter.try_reduce`](https://github.com/inko-lang/inko/commit/7314fd3bb6be1c7315af4c64c7a50e5d8c950cee)
- [`Bool.then`](https://github.com/inko-lang/inko/commit/4fe8a032b8310251ac6409bb751e42eb7f790499)
- [`Array.index_of`](https://github.com/inko-lang/inko/commit/317c3c7bf97b7017940531067548e53249a2778d)

## Type checking and type inference fixes

This release includes a variety of fixes related to type checking and type
inference, resolving the issues
[#588](https://github.com/inko-lang/inko/issues/588),
[#603](https://github.com/inko-lang/inko/issues/603),
[#620](https://github.com/inko-lang/inko/issues/620),
[#636](https://github.com/inko-lang/inko/issues/636),
[#642](https://github.com/inko-lang/inko/issues/642),
[#666](https://github.com/inko-lang/inko/issues/666).

## Following and supporting Inko

If Inko sounds like an interesting language, consider joining the [Discord
channel](https://discord.gg/seeURxHxCb). You can also follow along on the
[/r/inko subreddit](https://www.reddit.com/r/inko/). If you'd like to support
the continued development of Inko, please consider donating using [GitHub
Sponsors](https://github.com/sponsors/YorickPeterse).

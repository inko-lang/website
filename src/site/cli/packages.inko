import site.github
import std.env
import std.fs.file (ReadOnlyFile, WriteOnlyFile)
import std.fs.path (Path)
import std.int (Format)
import std.json (Json)
import std.net.http.client (Client)
import std.time (DateTime)

let ENV = 'GITHUB_TOKEN'
let QUERY = '
query ($owner: String!, $name: String!) {
  tags: repository(followRenames: true, owner: $owner, name: $name) {
    stargazerCount
    description
    url
    licenseInfo {
      spdxId
    }
    refs(
      refPrefix: "refs/tags/"
      first: 1
      orderBy: { field: ALPHABETICAL, direction: DESC }
    ) {
      nodes {
        name
        target {
          ... on Commit {
            committedDate
          }
          ... on Tag {
            target {
              ... on Commit {
                committedDate
              }
            }
          }
        }
      }
    }
  }
}
'

fn version_tag?(name: String) -> Bool {
  let vals = name
    .split('.')
    .map(fn (v) { Int.parse(v, Format.Decimal).some? })
    .to_array

  vals == [true, true, true]
}

fn registered(path: ref Path) -> Result[Array[(String, String)], String] {
  let path = Path.new('source').join('data').join('packages.json')
  let file = try ReadOnlyFile.new(path).map_error(fn (e) { e.to_string })
  let vals = match Json.parse(file) {
    case Ok(Array(v)) -> v
    case Ok(_) -> throw 'the top-level value must be an array'
    case Error(e) -> throw e.to_string
  }

  vals.into_iter.try_reduce([], fn (ary, val) {
    let owner = match val.query.key('owner').as_string {
      case Some(v) -> v
      case _ -> throw "the 'owner' key is invalid or missing"
    }

    let name = match val.query.key('name').as_string {
      case Some(v) -> v
      case _ -> throw "the 'name' key is invalid or missing"
    }

    ary.push((owner, name))
    Result.Ok(ary)
  })
}

fn packages(
  token: String,
  packages: Array[(String, String)],
) -> Result[Json, String] {
  let client = Client.new
  let rows = try packages.into_iter.try_reduce([], fn (ary, owner_name) {
    let vars = Map.new

    vars.set('owner', owner_name.0)
    vars.set('name', owner_name.1)

    let resp = try github.get(client, QUERY, token, vars)
    let repo = match resp.query.key('data').key('tags').as_object {
      case Some(v) -> v
      case _ -> return Result.Ok(ary)
    }

    let url = match repo.get('url') {
      case Ok(String(v)) -> v
      case _ -> ''
    }

    let desc = match repo.get('description') {
      case Ok(String(v)) -> v
      case _ -> ''
    }

    let stars = match repo.get('stargazerCount') {
      case Ok(Int(v)) -> v
      case _ -> 0
    }

    let license = match repo.get('licenseInfo') {
      case Ok(Object(m)) -> {
        match m.get('spdxId') {
          case Ok(String(v)) -> v
          case _ -> ''
        }
      }
      case _ -> ''
    }

    let tag = match repo.get('refs') {
      case Ok(Object(m)) -> {
        match m.get('nodes') {
          case Ok(Array(v)) -> {
            match v.get(0) {
              case Ok(Object(v)) -> v
              case _ -> return Result.Ok(ary)
            }
          }
          case _ -> return Result.Ok(ary)
        }
      }
      case _ -> return Result.Ok(ary)
    }

    let version = match tag.get('name') {
      case Ok(String(v)) -> {
        let name = if v.starts_with?('v') {
          v.slice(1, v.size).to_string
        } else {
          v
        }

        if !version_tag?(name) { return Result.Ok(ary) }

        name
      }
      case _ -> return Result.Ok(ary)
    }

    let row = Map.new

    row.set('owner', Json.String(owner_name.0))
    row.set('name', Json.String(owner_name.1))
    row.set('url', Json.String(url))
    row.set('description', Json.String(desc))
    row.set('stars', Json.Int(stars))
    row.set('license', Json.String(license))
    row.set('version', Json.String(version))

    ary.push(Json.Object(row))
    Result.Ok(ary)
  })

  let map = Map.new

  map.set('updated_at', Json.String(DateTime.utc.to_iso8601))
  map.set('packages', Json.Array(rows))
  Result.Ok(Json.Object(map))
}

fn pub run {
  let in_path = Path.new('source').join('data').join('packages.json')
  let out_path = Path.new('source').join('data').join('package_data.json')
  let token = match env.get(ENV) {
    case Ok(v) if v.size > 0 -> v
    case _ -> panic('the ${ENV} environment variable must be non-empty')
  }

  let input = match registered(in_path) {
    case Ok(v) -> v
    case Error(e) -> panic('failed to parse ${in_path}: ${e}')
  }

  let output = match packages(token, input) {
    case Ok(v) -> v
    case Error(e) -> panic('failed to get the packages: ${e}')
  }

  WriteOnlyFile
    .new(out_path)
    .then(fn (f) { f.write(output.to_pretty_string) })
    .or_panic_with('failed to write the packages')
}
